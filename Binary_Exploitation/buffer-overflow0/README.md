<h2> Buffer-overflow 0</h2>

1. The first step for this problem I did was to create a buffer-overflow directory

<img src = "images/1.png" height = 400, width = 400>

2. Then after both program and sorce code was downloaded using ``wget`` command

<img src = "images/2.png" height = 400, width = 400>
<img src = "images/3.png" height = 400, width = 400>

3. I tried executing  ``vuln`` file but could not execute due to different in architecture. Then I opened ``vuln.c`` file which is source code using ``vim`` editor

<img src = "images/4.png" height = 400, width = 400>

4. Here is the source code:
   We see that ``sigsev_handler`` prints a flag. ``sigsev_handler`` is a segmentation fault which can be exploited to get the fault. On the last lines we see ``gets`` function which takes ``buf1`` input without specified length and pass it to ``vuln`` which then passes to ``vuln`` function using ``strcpy``. 
<img src = "images/5.png" height = 400, width = 400>

5. We can overflow the function by passing undetermined length of input and then we get the flag.
<img src = "images/6.png" height = 400, width = 400>

<h2> Learned Concepts </h2>

<B>Buffer:</B> Buffers are the memory storage regions that temporarily hold data while it is being transferred from one location to another location. 

<B>Buffer overflow</B> attack occurs when the volume of data exceeds the storage capacity of the buffer. 

<B>Types of buffer overflow attacks:</B>

<B>Stack-based buffer overflows </B> are more common, and leverage stack memory that only exists during the execution time of a function.

<B>Heap-based attacks </B> are harder to carry out and involve flooding the memory space allocated for a program beyond the memory used for current runtime operations.

<B>A segmentation flaw </B> is a specific kind of error that occurs when you try to access memory that does not belong to you. It is a helper mechanism  that keeps you from corrupting the memory and introducing hard-to-debug memory bugs. Whenever you get a segfault you know you are doing something wrong with memory â€“ accessing a variable that has already been freed, writing to a read-only portion of the memory, etc. 

Here ``gets`` and ``strcpy`` are dangerous fucntion in ``#c`` which cause buffer overflow.
